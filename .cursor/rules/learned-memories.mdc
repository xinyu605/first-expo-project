---
description: This rule defines how the AI agent should manage and utilize memory improve coding consistency.
globs: *
alwaysApply: false
---

# Project Memory

This file stores project-specific knowledge, conventions, and user preferences learned by the AI assistant.

## User Preferences

- **Task List Structure**: Prefer detailed phase-based task lists with clear checkpoints for review
- **API Integration**: Use mock responses during development, with explicit tasks for removing mocks and integrating real APIs

## Technical Decisions

- **Package Manager**: Use yarn for package management throughout the project. When creating new React Native projects, use `yarn create react-native-app` instead of `npx react-native init` to maintain consistency with yarn ecosystem and avoid npm/yarn conflicts.

- **Early Return Pattern**: Prefer early return pattern over nested if statements for better code readability. Use early returns to reduce nesting levels and improve code flow. For example, instead of `if (condition) { if (nestedCondition) { return value } }`, use `if (!condition) return null; if (!nestedCondition) return null; return value;`.

- **Style Performance Optimization**: Use hybrid approach for optimal performance. Put static properties (layout, spacing, font sizes) in StyleSheet.create() for one-time calculation, and use inline styles only for theme-dependent colors. Avoid dynamic StyleSheet.create() inside components as it recalculates on every render.

- **Spacing System**: Use the standardized spacing system based on 4px grid. Import `spacing` from `@/theme` and use `spacing[number]` for consistent spacing values (e.g., `spacing[4]` for 16px). This ensures all margins, padding, and gaps follow a consistent scale.

- **Component Definition Pattern**: All components must use default export and const arrow function syntax. Use `const ComponentName = () => {}` instead of `function ComponentName() {}`. This ensures consistency across the codebase and follows modern React patterns.

- **ThemedButton Component Pattern**: Use ThemedButton component instead of TouchableOpacity + Text combinations for better consistency and maintainability. ThemedButton provides:
  - Multiple variants: primary, secondary, danger
  - Multiple sizes: small, medium, large  
  - Built-in theme integration
  - Consistent styling across the app
  - Better accessibility support
  - **Minimal API Surface**: Only exposes necessary props (title, variant, size, disabled, onPress, style) following the principle of least privilege

  Example usage:
  ```typescript
  <ThemedButton 
    title="按鈕文字"
    onPress={handlePress}
    variant="primary"
    size="medium"
  />
  ```

- **Component API Design Principle**: Follow the "Principle of Least Privilege" for component APIs. Only expose the minimum necessary props to maintain consistency and prevent style fragmentation. Avoid inheriting all parent component props unless absolutely necessary.

- **Component File Structure**: Organize components with clear separation of concerns:
  - **Common Components**: Place reusable themed components in `components/common/`
  - **Complex Components**: Use folder structure with `index.tsx` and `types.ts` for components with multiple files
  - **Type Exports**: Export types separately for better reusability and cleaner imports
  - **Props Type Pattern**: Use `Props` type inside component files, don't export component props. External usage should use `ComponentProps<typeof ComponentName>` instead
  - **Example Structure**:
    ```
    components/
    ├── common/
    │   ├── ThemedButton/
    │   │   ├── index.tsx        # Contains Props type internally
    │   │   └── types.ts        # Only exports reusable Union types
    │   ├── ThemedText.tsx
    │   └── ThemedView.tsx
    ├── ui/
    └── settings/
    ```

- **Conditional Logic Readability**: Use helper functions with early returns for complex conditional logic. Instead of nested if-else statements or complex ternary operators, create helper functions like `getColor()` or `getBackgroundColor()` that use early returns. This pattern is more readable, follows the early return convention, and makes the code easier to test and maintain.

- **Absolute Path Usage**: Use absolute paths with `@/` prefix for files that are more than one level away. For files that are only one level away (e.g., `../`), relative paths are acceptable. Use `@/lib/AyLocale`, `@/constants`, `@/assets/icon/logo.png` instead of `../../../../lib/AyLocale`, `../../../../constants`, `../../../../assets/icon/logo.png`. However, `../styled` or `../constants` are acceptable. This improves code readability, maintainability, and prevents path errors when files are moved or restructured.

## Project Conventions

- **Documentation Organization**:

  - Main task index file (`README.md`) at project root for overview
  - Detailed feature task lists stored in `docs/tasks/` folder
  - Use UPPERCASE naming for all project-level documents
  - Link detailed documentation from main task index

- **Task List Management**:
  - Keep `README.md` as a clean overview index with minimal information
  - Detailed progress tracking should be managed in individual feature task lists
  - `README.md` should only show: feature name, status, documentation link, and brief description
  - **Progress Tracking Strategy**:
    - Use `README.md` for feature overview and navigation
    - Use individual feature documents for detailed phase progress
    - This provides clean separation of concerns and prevents information overload

- **React Native + Expo Learning Project Structure**:
  - Main learning guide in `README.md` with overview and navigation
  - Detailed weekly/daily tasks in `docs/tasks/` with UPPERCASE naming
  - Each task file contains: objectives, learning topics, implementation tasks, acceptance criteria, troubleshooting
  - Focus on practical learning with 20% reading, 80% hands-on implementation
  - Progressive complexity from basic RN concepts to advanced Expo ecosystem integration
